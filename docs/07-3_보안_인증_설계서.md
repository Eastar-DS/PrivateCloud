# 보안 및 인증 설계서

## 공공기관 AI 공동 활용 인프라 구축 프로젝트
### AI 기반 문서 태깅 시스템을 위한 프라이빗 클라우드 설계

| 항목 | 내용 |
|------|------|
| 문서명 | 보안 및 인증 설계서 |
| 버전 | 2.0 |
| 작성일 | 2026-02-10 |
| 프로젝트명 | 공공기관 AI 공동 활용 인프라 구축 |
| 상위 문서 | 07_백엔드_설계서.md |

---

**목차**

1. [인증 설계](#1-인증-설계)
2. [RBAC 권한 관리](#2-rbac-권한-관리)
3. [테넌트 격리](#3-테넌트-격리)
4. [감사 로그](#4-감사-로그)
5. [전송 보안](#5-전송-보안)
6. [데이터 보안](#6-데이터-보안)
7. [입력 검증](#7-입력-검증)
8. [Rate Limiting](#8-rate-limiting)
9. [요청 추적](#9-요청-추적)

---

## 1. 인증 설계

### 1.1 인증 전제 조건

> **중요**: 본 시스템은 로그인 기능을 구현하지 않는다.
> 기관의 기존 내부 인증 시스템(SSO/AD)이 존재함을 전제로 하며,
> 인증된 사용자 정보를 HTTP 헤더를 통해 수신하여 처리한다.

| 항목 | 내용 |
|------|------|
| 인증 방식 | 외부 인증 시스템(SSO/AD)에서 전달된 헤더 기반 |
| 로그인 구현 | 미구현 (기존 시스템 위임) |
| 사용자 등록 | 최초 접근 시 자동 등록 (upsert) |
| 세션 관리 | Stateless (요청별 헤더 검증) |

### 1.2 인증 헤더 정의

외부 인증 시스템이 Reverse Proxy(nginx)를 통해 다음 헤더를 주입한다.

| 헤더 | 필수 여부 | 설명 | 예시 |
|------|----------|------|------|
| `X-User-ID` | 필수 | 사용자 고유 식별자 | `user-001` |
| `X-Department-ID` | 필수 | 소속 부서(테넌트) 식별자 | `dept-a` |
| `X-Role` | 필수 | 사용자 역할 | `dept-user` |

- 세 헤더 중 하나라도 누락되면 `401 Unauthorized` 응답을 반환한다.
- `X-User-ID`와 `X-Department-ID` 조합은 users 테이블에 upsert 된다.
- 클라이언트가 직접 해당 헤더를 설정하는 것을 방지하기 위해 nginx에서 기존 헤더를 제거한 후 인증 시스템이 주입하도록 구성한다.

### 1.3 Spring Security Filter Chain

요청 처리 순서는 다음과 같다.

```
[클라이언트] → [nginx (TLS 종료)] → [Spring Security Filter Chain] → [Controller]

Filter Chain 순서:
1. TenantContextFilter     - 인증 헤더 파싱, 사용자 자동 등록, SecurityContext 설정
2. RbacAuthorizationFilter - 역할 기반 접근 제어 검증
3. (DispatcherServlet)     - 비즈니스 로직 실행
```

### 1.4 TenantContextFilter 구현

```java
/** 인증 헤더에서 사용자/테넌트 정보를 추출하고, 최초 접근 시 upsert하는 필터. */
@Component
@Order(1)
public class TenantContextFilter extends OncePerRequestFilter {

    private static final String HEADER_USER_ID = "X-User-ID";
    private static final String HEADER_DEPT_ID = "X-Department-ID";
    private static final String HEADER_ROLE    = "X-Role";

    private final UserRepository userRepository;

    public TenantContextFilter(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        String userId = request.getHeader(HEADER_USER_ID);
        String deptId = request.getHeader(HEADER_DEPT_ID);
        String role   = request.getHeader(HEADER_ROLE);

        // 1) 필수 헤더 검증
        if (userId == null || deptId == null || role == null) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write("{\"error\":\"Missing authentication headers\"}");
            return;
        }

        // 2) 역할 유효성 검증
        if (!RoleType.isValid(role)) {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            response.getWriter().write("{\"error\":\"Invalid role: " + role + "\"}");
            return;
        }

        // 3) 사용자 자동 등록 (upsert)
        UserEntity user = userRepository.upsert(userId, deptId, RoleType.valueOf(role));

        // 4) TenantContext 설정 (ThreadLocal)
        TenantContext.set(new TenantInfo(userId, deptId, RoleType.valueOf(role)));

        // 5) Spring SecurityContext 설정
        var authorities = List.of(new SimpleGrantedAuthority("ROLE_" + role.toUpperCase()));
        var authentication = new PreAuthenticatedAuthenticationToken(user, null, authorities);
        SecurityContextHolder.getContext().setAuthentication(authentication);

        try {
            filterChain.doFilter(request, response);
        } finally {
            // 6) ThreadLocal 정리
            TenantContext.clear();
            SecurityContextHolder.clearContext();
        }
    }
}
```

### 1.5 사용자 자동 등록 (Upsert)

최초 접근 시 users 테이블에 사용자를 자동 등록한다.

```java
/** 사용자 upsert: 존재하면 last_login_at 갱신, 없으면 신규 등록. */
@Repository
public class UserRepositoryImpl implements UserRepository {

    @Transactional
    public UserEntity upsert(String userId, String deptId, RoleType role) {
        return userJpaRepository.findByUserId(userId)
                .map(existing -> {
                    existing.updateLastLogin();
                    return existing;
                })
                .orElseGet(() -> {
                    UserEntity newUser = UserEntity.builder()
                            .userId(userId)
                            .departmentId(deptId)
                            .role(role)
                            .build();
                    return userJpaRepository.save(newUser);
                });
    }
}
```

---

## 2. RBAC 권한 관리

### 2.1 역할 정의

| 역할 | 코드 | 설명 | 대상 범위 |
|------|------|------|----------|
| 플랫폼 관리자 | `platform-admin` | 전체 시스템 관리자. 모든 테넌트의 모든 리소스에 접근 가능 | 전체 |
| 부서 관리자 | `dept-admin` | 소속 부서의 문서, 태그, 사용자를 관리 | 소속 부서 |
| 부서 사용자 | `dept-user` | 소속 부서에 문서 업로드 및 조회, 검색 수행 | 소속 부서 |
| 열람자 | `viewer` | 소속 부서의 문서 조회 및 검색만 가능 (읽기 전용) | 소속 부서 |

### 2.2 권한 매트릭스

아래 표에서 **O**는 허용, **X**는 거부를 나타낸다. 괄호 안은 접근 가능 범위이다.

| 기능 | platform-admin | dept-admin | dept-user | viewer |
|------|---------------|-----------|----------|--------|
| 문서 업로드 | O (전체) | O (소속) | O (소속) | X |
| 문서 조회 | O (전체) | O (소속) | O (소속) | O (소속) |
| 문서 다운로드 | O (전체) | O (소속) | O (소속) | O (소속) |
| 문서 삭제 | O (전체) | O (소속) | X | X |
| 태그 교정 | O (전체) | O (소속) | X | X |
| 태그 삭제 | O (전체) | O (소속) | X | X |
| 검색 | O (전체) | O (소속) | O (소속) | O (소속) |
| 테넌트 생성/수정 | O | X | X | X |
| 사용자 관리 | O (전체) | O (소속) | X | X |
| 감사 로그 조회 | O (전체) | O (소속) | X | X |
| 시스템 설정 | O | X | X | X |

### 2.3 엔드포인트별 접근 제어

| HTTP Method | 엔드포인트 | platform-admin | dept-admin | dept-user | viewer |
|-------------|-----------|---------------|-----------|----------|--------|
| POST | `/api/documents` | O | O | O | X |
| GET | `/api/documents` | O | O | O | O |
| GET | `/api/documents/{documentId}` | O | O | O | O |
| GET | `/api/documents/{documentId}/tags` | O | O | O | O |
| GET | `/api/documents/{documentId}/ocr` | O | O | O | O |
| GET | `/api/search/documents` | O | O | O | O |
| POST | `/api/jobs` | O | O | O | X |
| GET | `/api/jobs/{jobId}` | O | O | O | O |
| POST | `/api/jobs/{jobId}/retry` | O | O | O | X |
| GET | `/api/users/me` | O | O | O | O |
| GET | `/api/health` | 인증 불필요 | 인증 불필요 | 인증 불필요 | 인증 불필요 |

### 2.4 RbacAuthorizationFilter 구현

```java
/** RBAC 기반 접근 제어 필터. 역할과 엔드포인트를 대조하여 접근을 허용/거부한다. */
@Component
@Order(2)
public class RbacAuthorizationFilter extends OncePerRequestFilter {

    private final RbacPolicyRegistry policyRegistry;

    public RbacAuthorizationFilter(RbacPolicyRegistry policyRegistry) {
        this.policyRegistry = policyRegistry;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        TenantInfo tenant = TenantContext.get();
        String method = request.getMethod();
        String path = request.getRequestURI();

        // 역할별 엔드포인트 접근 정책 확인
        if (!policyRegistry.isAllowed(tenant.getRole(), method, path)) {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            response.getWriter().write("{\"error\":\"Access denied\"}");
            // 접근 거부 감사 로그 기록
            AuditLogger.log(AuditAction.ACCESS_DENIED, tenant, path);
            return;
        }

        filterChain.doFilter(request, response);
    }
}
```

---

## 3. 테넌트 격리

### 3.1 격리 원칙

| 계층 | 격리 방식 | 설명 |
|------|----------|------|
| 네트워크 | 역할별 VLAN | DMZ(10), 백엔드(20), AI(30), DB(40), 스토리지(50), 관리(100) |
| 데이터베이스 | Row-Level 필터링 | Hibernate `@Filter`로 자동 WHERE tenant_id 조건 추가 |
| API | DepartmentContext | 모든 요청에 부서(테넌트) ID 필수 포함 (X-Department-ID 헤더) |

### 3.2 Hibernate @Filter 기반 자동 격리

모든 테넌트 소속 엔티티에는 `tenant_id` 컬럼이 존재하며, Hibernate `@Filter`와 `@FilterDef`를 사용하여 자동으로 `WHERE tenant_id = :tenantId` 조건을 추가한다.

```java
/** 테넌트 격리를 위한 공통 부모 엔티티. 모든 테넌트 소속 엔티티가 상속한다. */
@MappedSuperclass
@FilterDef(
    name = "tenantFilter",
    parameters = @ParamDef(name = "tenantId", type = String.class)
)
@Filter(name = "tenantFilter", condition = "tenant_id = :tenantId")
public abstract class TenantBaseEntity {

    @Column(name = "tenant_id", nullable = false, updatable = false)
    private String tenantId;

    @PrePersist
    public void prePersist() {
        // 저장 시 현재 TenantContext에서 tenantId를 자동 설정
        if (this.tenantId == null) {
            this.tenantId = TenantContext.get().getDepartmentId();
        }
    }
}
```

### 3.3 테넌트 필터 활성화

```java
/** Hibernate 세션에 테넌트 필터를 활성화하는 AOP. platform-admin은 우회. */
@Aspect
@Component
public class TenantFilterAspect {

    @PersistenceContext
    private EntityManager entityManager;

    @Before("execution(* com.sesac.smartdocs..service..*(..))")
    public void enableTenantFilter() {
        TenantInfo tenant = TenantContext.get();
        if (tenant == null) {
            throw new SecurityException("TenantContext is not set");
        }

        // platform-admin은 필터를 적용하지 않음 (전체 접근)
        if (tenant.getRole() == RoleType.PLATFORM_ADMIN) {
            return;
        }

        // Hibernate 세션에 테넌트 필터 활성화
        Session session = entityManager.unwrap(Session.class);
        session.enableFilter("tenantFilter")
               .setParameter("tenantId", tenant.getDepartmentId());
    }
}
```

### 3.4 테넌트 격리 보장 규칙

| 규칙 | 설명 |
|------|------|
| 자동 WHERE 조건 | 모든 JPA 조회 쿼리에 `tenant_id` 조건이 자동 추가됨 |
| 저장 시 자동 설정 | `@PrePersist`에서 TenantContext의 `departmentId`를 자동 설정 |
| platform-admin 예외 | `platform-admin` 역할은 테넌트 필터를 우회하여 전체 데이터 접근 |
| Native Query 금지 | 프레임워크 필터를 우회할 수 있는 Native SQL 사용을 금지 |
| 테넌트 변경 불가 | `tenant_id` 컬럼은 `updatable = false`로 설정하여 변경 불가 |

---

## 4. 감사 로그

### 4.1 감사 대상 액션

| 액션 코드 | 설명 | 리소스 |
|-----------|------|--------|
| `DOCUMENT_UPLOAD` | 문서 업로드 | DOCUMENT |
| `DOCUMENT_VIEW` | 문서 조회 | DOCUMENT |
| `DOCUMENT_DOWNLOAD` | 문서 다운로드 | DOCUMENT |
| `DOCUMENT_DELETE` | 문서 삭제 | DOCUMENT |
| `TAG_AUTO` | AI 자동 태깅 | TAG |
| `TAG_EDIT` | 태그 수동 교정 | TAG |
| `TAG_DELETE` | 태그 삭제 | TAG |
| `SEARCH` | 검색 수행 | SEARCH |
| `TENANT_CREATE` | 테넌트 생성 | TENANT |
| `TENANT_UPDATE` | 테넌트 수정 | TENANT |
| `USER_REGISTER` | 사용자 등록 (자동) | USER |
| `AUTH_FAILURE` | 인증 실패 (헤더 누락 등) | AUTH |
| `ACCESS_DENIED` | 접근 거부 (RBAC 위반) | AUTH |

### 4.2 감사 로그 테이블

```sql
CREATE TABLE audit_logs (
    id          BIGINT AUTO_INCREMENT PRIMARY KEY,
    action      VARCHAR(50)  NOT NULL COMMENT '액션 코드',
    resource    VARCHAR(50)  NOT NULL COMMENT '리소스 유형',
    resource_id VARCHAR(255) NULL     COMMENT '대상 리소스 식별자',
    user_id     VARCHAR(100) NOT NULL COMMENT '수행 사용자 ID',
    tenant_id   VARCHAR(100) NOT NULL COMMENT '테넌트(부서) ID',
    request_id  VARCHAR(36)  NOT NULL COMMENT '요청 추적 ID (UUID)',
    ip_address  VARCHAR(45)  NULL     COMMENT '클라이언트 IP',
    detail      JSON         NULL     COMMENT '추가 상세 정보',
    result      VARCHAR(20)  NOT NULL DEFAULT 'SUCCESS' COMMENT 'SUCCESS/FAILURE',
    created_at  DATETIME(3)  NOT NULL DEFAULT CURRENT_TIMESTAMP(3),

    INDEX idx_audit_tenant_created (tenant_id, created_at),
    INDEX idx_audit_action_created (action, created_at),
    INDEX idx_audit_user_created   (user_id, created_at),
    INDEX idx_audit_request_id     (request_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  PARTITION BY RANGE (YEAR(created_at) * 100 + MONTH(created_at)) (
    PARTITION p202602 VALUES LESS THAN (202603),
    PARTITION p202603 VALUES LESS THAN (202604),
    PARTITION p202604 VALUES LESS THAN (202605),
    PARTITION p202605 VALUES LESS THAN (202606),
    PARTITION p_future VALUES LESS THAN MAXVALUE
  );
```

### 4.3 @Auditable 어노테이션

```java
/** 감사 로그 기록 대상 메서드에 선언하는 어노테이션. */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Auditable {

    /** 감사 액션 코드 */
    AuditAction action();

    /** 리소스 유형 */
    String resource() default "";

    /** SpEL 표현식으로 리소스 ID 추출 (예: "#documentId") */
    String resourceId() default "";
}
```

### 4.4 AuditAspect 구현

```java
/** @Auditable 어노테이션이 선언된 메서드 실행 시 감사 로그를 자동 기록하는 AOP. */
@Aspect
@Component
@Slf4j
public class AuditAspect {

    private final AuditLogRepository auditLogRepository;
    private final SpelExpressionParser parser = new SpelExpressionParser();

    public AuditAspect(AuditLogRepository auditLogRepository) {
        this.auditLogRepository = auditLogRepository;
    }

    @Around("@annotation(auditable)")
    public Object audit(ProceedingJoinPoint joinPoint, Auditable auditable) throws Throwable {
        TenantInfo tenant = TenantContext.get();
        String requestId = RequestContext.getRequestId();
        String resourceId = resolveResourceId(auditable.resourceId(), joinPoint);

        AuditLogEntity auditLog = AuditLogEntity.builder()
                .action(auditable.action().name())
                .resource(auditable.resource())
                .resourceId(resourceId)
                .userId(tenant.getUserId())
                .tenantId(tenant.getDepartmentId())
                .requestId(requestId)
                .ipAddress(RequestContext.getClientIp())
                .build();

        try {
            Object result = joinPoint.proceed();
            auditLog.setResult("SUCCESS");
            return result;
        } catch (Exception e) {
            auditLog.setResult("FAILURE");
            auditLog.setDetail("{\"error\":\"" + e.getMessage() + "\"}");
            throw e;
        } finally {
            // 비동기로 감사 로그 저장 (비즈니스 로직에 영향을 주지 않음)
            auditLogRepository.saveAsync(auditLog);
        }
    }

    private String resolveResourceId(String expression, ProceedingJoinPoint joinPoint) {
        if (expression == null || expression.isEmpty()) {
            return null;
        }
        StandardEvaluationContext context = new StandardEvaluationContext();
        String[] paramNames = ((MethodSignature) joinPoint.getSignature()).getParameterNames();
        Object[] args = joinPoint.getArgs();
        for (int i = 0; i < paramNames.length; i++) {
            context.setVariable(paramNames[i], args[i]);
        }
        return parser.parseExpression(expression).getValue(context, String.class);
    }
}
```

### 4.5 @Auditable 사용 예시

```java
@Service
public class DocumentService {

    @Auditable(action = AuditAction.DOCUMENT_UPLOAD, resource = "DOCUMENT")
    public DocumentResponse uploadDocument(MultipartFile file) {
        // 문서 업로드 비즈니스 로직
    }

    @Auditable(action = AuditAction.DOCUMENT_VIEW, resource = "DOCUMENT", resourceId = "#documentId")
    public DocumentResponse getDocument(String documentId) {
        // 문서 조회 비즈니스 로직
    }

    @Auditable(action = AuditAction.DOCUMENT_DELETE, resource = "DOCUMENT", resourceId = "#documentId")
    public void deleteDocument(String documentId) {
        // 문서 삭제 비즈니스 로직
    }
}
```

### 4.6 감사 로그 보관 정책

| 로그 유형 | 보관 기간 | 대상 액션 |
|----------|----------|----------|
| 접근 로그 | 90일 | `DOCUMENT_VIEW`, `DOCUMENT_DOWNLOAD`, `SEARCH` |
| 변경 로그 | 1년 | `DOCUMENT_UPLOAD`, `DOCUMENT_DELETE`, `TAG_AUTO`, `TAG_EDIT`, `TAG_DELETE` |
| 보안 로그 | 1년 | `AUTH_FAILURE`, `ACCESS_DENIED`, `USER_REGISTER` |
| 관리 로그 | 1년 | `TENANT_CREATE`, `TENANT_UPDATE` |

- 보관 기간이 경과한 파티션은 월별 배치 작업으로 삭제한다.
- 삭제 전 콜드 스토리지로 아카이빙을 수행한다.
- `created_at` 기준 월별 파티셔닝으로 삭제 시 성능 저하를 방지한다.

---

## 5. 전송 보안

### 5.1 구간별 암호화 정책

```
[기관 내부 사용자]
      │
      │  TLS 1.3 (HTTPS 443)
      ▼
[nginx - TLS Termination] (VLAN 10 - DMZ)
      │
      │  HTTP (VLAN 10 → 20)
      ▼
[Spring Boot App 서버 + AMQP Consumer] (VLAN 20 - 백엔드망)
      │
      ├──── HTTP :8001/:8000 ► [AI 서버 (OCR/태깅 FastAPI)] (VLAN 30 - AI망)
      ├──── TCP 3306 ────────► [MariaDB] (VLAN 40 - DB망)
      └──── NFS mount ─────────► [CephFS NFS] (VLAN 50 - 스토리지망)
```

| 구간 | 프로토콜 | 암호화 | 비고 |
|------|---------|--------|------|
| 사용자 - nginx | TLS 1.3 | AES-256-GCM | 외부 접근 구간, HSTS 적용 |
| nginx - App 서버 | HTTP | 없음 (VLAN 10→20) | DMZ→백엔드, 방화벽 허용 |
| App 서버 - AI 서버 | HTTP :8001/:8000 | 없음 (VLAN 20→30) | AMQP Consumer → AI FastAPI |
| App 서버 - MariaDB | TCP 3306 | SSL 선택적 | VLAN 20→40, DB망 |
| App 서버 - RabbitMQ | TCP 5672 | 없음 (VLAN 20 내부) | 동일 VLAN 내부 통신 |
| App 서버 - Ceph | NFS mount | 없음 (VLAN 20→50) | 스토리지망 |

### 5.2 TLS 설정 기준

| 항목 | 설정 |
|------|------|
| 최소 TLS 버전 | TLS 1.3 |
| 암호 스위트 | TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256 |
| HSTS | `max-age=31536000; includeSubDomains` |
| 인증서 | 기관 내부 CA 발급 |
| 인증서 갱신 | 1년 주기, 만료 30일 전 알림 |

---

## 6. 데이터 보안

### 6.1 파일 무결성 검증 (NFR-10)

문서 업로드 시 SHA-256 해시를 계산하여 저장하고, 다운로드 시 재계산하여 비교한다.

```java
/** 파일 무결성 검증 서비스. 업로드 시 해시 계산, 다운로드 시 재검증. */
@Service
public class FileIntegrityService {

    private static final String ALGORITHM = "SHA-256";

    /** 업로드 시 해시 계산 */
    public String calculateHash(InputStream inputStream) throws Exception {
        MessageDigest digest = MessageDigest.getInstance(ALGORITHM);
        byte[] buffer = new byte[8192];
        int bytesRead;
        while ((bytesRead = inputStream.read(buffer)) != -1) {
            digest.update(buffer, 0, bytesRead);
        }
        byte[] hashBytes = digest.digest();
        return HexFormat.of().formatHex(hashBytes);
    }

    /** 다운로드 시 무결성 검증 */
    public void verifyIntegrity(String storedHash, InputStream fileStream) throws Exception {
        String currentHash = calculateHash(fileStream);
        if (!storedHash.equals(currentHash)) {
            throw new IntegrityViolationException(
                "파일 무결성 검증 실패: 저장된 해시=" + storedHash + ", 현재 해시=" + currentHash
            );
        }
    }
}
```

### 6.2 저장 데이터 암호화

| 대상 | 암호화 방식 | 키 관리 | 비고 |
|------|-----------|--------|------|
| MariaDB | TDE (AES-256) | MariaDB 자체 키 관리 | 메타데이터, 사용자 정보, 감사 로그 |
| Ceph | AES-256-XTS | Ceph 자체 암호화 | 문서 원본 파일 |
| 백업 데이터 | AES-256 | 별도 키 관리 | 스냅샷 및 아카이브 |

### 6.3 비밀 정보 관리

| 항목 | 관리 방식 |
|------|----------|
| DB 접속 정보 | 환경 변수 (`SPRING_DATASOURCE_PASSWORD`) |
| NFS 마운트 설정 | 환경 변수 (`NFS_MOUNT_PATH`) 및 `/etc/fstab` 설정 |
| RabbitMQ 인증 | 환경 변수 (`RABBITMQ_PASSWORD`) |
| TLS 인증서/키 | 볼륨 마운트 (파일 시스템) |

- 소스 코드에 비밀 정보를 절대 포함하지 않는다.
- `application.yml`에서 `${ENV_VAR}` 형식으로 환경 변수를 참조한다.
- `.env` 파일은 `.gitignore`에 반드시 등록한다.

---

## 7. 입력 검증

### 7.1 Bean Validation

모든 API 요청 DTO에 Bean Validation 어노테이션을 적용한다.

```java
public class DocumentUploadRequest {

    @NotBlank(message = "파일명은 필수입니다")
    @Size(max = 255, message = "파일명은 255자 이하여야 합니다")
    private String fileName;

    @NotBlank(message = "설명은 필수입니다")
    @Size(max = 1000, message = "설명은 1000자 이하여야 합니다")
    private String description;

    @NotNull(message = "파일은 필수입니다")
    private MultipartFile file;
}
```

컨트롤러에서 `@Valid`를 사용하여 자동 검증한다.

```java
@PostMapping("/api/documents")
public ResponseEntity<DocumentResponse> upload(@Valid @ModelAttribute DocumentUploadRequest request) {
    // 검증 통과 후 비즈니스 로직 실행
}
```

### 7.2 파일 업로드 검증

| 검증 항목 | 정책 | 비고 |
|----------|------|------|
| 허용 확장자 | PDF, TXT, DOCX, HWP | 화이트리스트 방식 (MVP) |
| 최대 파일 크기 | 20MB | `spring.servlet.multipart.max-file-size=20MB` |
| Content-Type 검증 | Magic Bytes 기반 | 확장자만 변경한 위장 파일 차단 |
| 파일명 검증 | 경로 순회 문자 (`..`, `/`, `\`) 차단 | 디렉토리 순회 공격 방지 |

```java
@Component
public class FileValidator {

    private static final Set<String> ALLOWED_EXTENSIONS = Set.of(
        "pdf", "txt", "docx", "hwp"
    );

    private static final long MAX_FILE_SIZE = 20 * 1024 * 1024; // 20MB

    public void validate(MultipartFile file) {
        // 1) 파일 크기 검증
        if (file.getSize() > MAX_FILE_SIZE) {
            throw new FileValidationException("파일 크기가 20MB를 초과합니다");
        }

        // 2) 확장자 화이트리스트 검증
        String extension = getExtension(file.getOriginalFilename()).toLowerCase();
        if (!ALLOWED_EXTENSIONS.contains(extension)) {
            throw new FileValidationException("허용되지 않는 파일 형식입니다: " + extension);
        }

        // 3) 파일명 경로 순회 검증
        String filename = file.getOriginalFilename();
        if (filename != null && (filename.contains("..") || filename.contains("/") || filename.contains("\\"))) {
            throw new FileValidationException("유효하지 않은 파일명입니다");
        }
    }
}
```

### 7.3 SQL Injection 방지

| 방어 수단 | 적용 방식 |
|----------|----------|
| JPA Parameterized Query | 모든 데이터 접근에 JPA/JPQL 사용 |
| Native Query 금지 | 프레임워크 필터 우회 방지 (3.4절 참조) |
| 입력값 검증 | Bean Validation으로 사전 검증 |

### 7.4 XSS 방지

| 방어 수단 | 적용 방식 |
|----------|----------|
| Content-Type | 모든 응답에 `application/json` 사용 |
| HTML 렌더링 없음 | 백엔드 API는 JSON만 반환 (프론트엔드 SPA 구조) |
| 입력 이스케이프 | 태그명, 문서 설명 등 사용자 입력은 저장 전 이스케이프 |

---

## 8. Rate Limiting

### 8.1 테넌트별 Rate Limiting 정책

부서별로 API 호출 빈도를 제한하여 특정 부서의 과도한 사용이 다른 부서에 영향을 주는 것을 방지한다.

| 엔드포인트 | 제한 | 단위 | 비고 |
|-----------|------|------|------|
| `POST /api/documents` (업로드) | 100 req/min | 부서별 | 파일 업로드 + AI 태깅 부하 고려 |
| `GET /api/search/documents` (검색) | 500 req/min | 부서별 | 검색 쿼리 부하 고려 |
| 기타 엔드포인트 | 1,000 req/min | 부서별 | 일반 API 호출 |

### 8.2 Rate Limiting 구현

- Spring Boot에서 Bucket4j 또는 직접 구현한 인터셉터를 사용한다.
- Rate Limit 키는 `tenant_id` 기준으로 생성한다.
- 제한 초과 시 `429 Too Many Requests` 응답과 함께 `Retry-After` 헤더를 반환한다.

```
HTTP/1.1 429 Too Many Requests
Content-Type: application/json
Retry-After: 30

{
  "error": "Rate limit exceeded",
  "limit": 100,
  "remaining": 0,
  "retryAfter": 30
}
```

### 8.3 platform-admin 예외

`platform-admin` 역할은 운영 및 긴급 대응을 위해 Rate Limiting을 적용하지 않는다.

---

## 9. 요청 추적

### 9.1 X-Request-ID 체계

모든 API 요청에 고유한 `X-Request-ID`를 부여하여 전체 처리 과정을 추적한다.

| 항목 | 내용 |
|------|------|
| 헤더 이름 | `X-Request-ID` |
| 형식 | UUID v4 (예: `550e8400-e29b-41d4-a716-446655440000`) |
| 생성 시점 | nginx에서 최초 생성 (클라이언트 전달 시 해당 값 사용) |
| 전파 범위 | nginx - App 서버 - AMQP Consumer - AI 서버 - DB - 감사 로그 |

### 9.2 요청 추적 흐름

```
[클라이언트]
    │
    │ X-Request-ID: (없으면 nginx에서 생성)
    ▼
[nginx]
    │ X-Request-ID: 550e8400-...
    ▼
[App 서버 - RequestContextFilter]
    │ MDC.put("requestId", "550e8400-...")
    │ → 모든 로그에 requestId 포함
    ▼
[비즈니스 로직]
    │ → 감사 로그에 request_id 저장
    ▼
[RabbitMQ 메시지 헤더]
    │ x-request-id: 550e8400-...
    ▼
[AMQP Consumer → AI 서버 (OCR/태깅 FastAPI)]
    │ → Consumer/AI 서버 로그에도 동일한 requestId 포함
```

### 9.3 로그 형식

모든 애플리케이션 로그에 `requestId`를 포함하여 출력한다.

```
[2026-02-09T10:30:00.123Z] [INFO] [requestId=550e8400-...] [userId=user-001] [tenantId=dept-a]
  DocumentService.uploadDocument - 문서 업로드 시작: filename=report.pdf, size=2048576
```

---

## 변경 이력

| 버전 | 날짜 | 변경 내용 | 작성자 |
|------|------|----------|--------|
| 1.0 | 2026-02-09 | 초안 작성: 인증, RBAC, 테넌트 격리, 감사 로그, 전송/데이터 보안, 입력 검증, Rate Limiting, 요청 추적 | - |
| 2.0 | 2026-02-10 | VLAN 재설계 반영, /api/ 프리픽스 변경, MVP 엔드포인트 11개 접근 제어 업데이트, 파일 크기 20MB, AI 서버 HTTP 연동 반영 | - |

---

## 관련 문서

- [07_백엔드_설계서.md](07_백엔드_설계서.md) - 백엔드 설계서 (상위 문서)
- [00_요구사항_명세서.md](00_요구사항_명세서.md) - 요구사항 명세서
- [05_네트워크_보안_설계서.md](05_네트워크_보안_설계서.md) - 네트워크/보안 설계서 (인프라 계층)
- [06_스토리지_설계서.md](06_스토리지_설계서.md) - 스토리지 설계서
