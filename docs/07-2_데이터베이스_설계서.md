# 데이터베이스 설계서

## 공공기관 AI 공동 활용 인프라 구축 프로젝트
### AI 기반 문서 태깅 시스템을 위한 프라이빗 클라우드 설계

| 항목 | 내용 |
|------|------|
| 문서명 | 데이터베이스 설계서 |
| 버전 | 2.0 |
| 작성일 | 2026-02-10 |
| 프로젝트명 | 공공기관 AI 공동 활용 인프라 구축 |
| 상위 문서 | 07_백엔드_설계서.md |

---

**목차**

1. [데이터베이스 개요](#1-데이터베이스-개요)
2. [ERD 개념도](#2-erd-개념도)
3. [테이블 스키마 상세](#3-테이블-스키마-상세)
4. [인덱스 전략](#4-인덱스-전략)
5. [읽기/쓰기 분리](#5-읽기쓰기-분리)
6. [검색 설계](#6-검색-설계)
7. [DB 마이그레이션](#7-db-마이그레이션)

---

## 1. 데이터베이스 개요

### 1.1 DBMS 선정

| 항목 | 내용 |
|------|------|
| **DBMS** | MariaDB 11.4 LTS |
| **Database** | sesac_smartdocs |
| **문자셋** | utf8mb4 |
| **Collation** | utf8mb4_unicode_ci |
| **스토리지 엔진** | InnoDB |

### 1.2 서버 구성

부서별 데이터 격리와 읽기 성능을 보장하기 위해 Primary-Replica 이중화 구성을 적용한다.

| 역할 | 호스트명 | VLAN | IP 대역 | 용도 |
|------|----------|------|---------|------|
| **Primary** | dev-data-db-pri | VLAN 40 | 10.0.40.x | Read / Write |
| **Replica** | dev-data-db-rep | VLAN 40 | 10.0.40.x | Read Only |

### 1.3 주요 설정

```ini
[mysqld]
character-set-server       = utf8mb4
collation-server           = utf8mb4_unicode_ci
default-storage-engine     = InnoDB

# InnoDB 설정
innodb_buffer_pool_size    = 4G
innodb_log_file_size       = 512M
innodb_flush_log_at_trx_commit = 1

# 복제 설정
server-id                  = 1          # Primary: 1, Replica: 2
log_bin                    = mysql-bin
binlog_format              = ROW
gtid_strict_mode           = ON
```

---

## 2. ERD 개념도

SmartDocs 데이터베이스는 6개의 테이블로 구성되며, 부서(테넌트) 기반의 데이터 격리를 지원한다.

```
┌──────────────┐          ┌───────────────────┐          ┌──────────────┐
│   tenants    │          │    documents      │          │     tags     │
│──────────────│          │───────────────────│          │──────────────│
│ id       (PK)│──── 1:N ──│ tenant_id    (FK)│          │ id       (PK)│
│ name         │          │ uploaded_by  (FK)│── 1:N ──│ document_id(FK)│
│ code     (UQ)│          │ title            │          │ tenant_id    │
│ quota_bytes  │          │ document_type    │          │ name         │
│ used_bytes   │          │ content_text     │          │ confidence   │
│ is_active    │          │ file_name        │          │ source       │
│ created_at   │          │ sha256_hash      │          │ model_version│
│ updated_at   │          │ ocr_text         │          │ created_at   │
└──────────────┘          │ tagging_status   │          └──────────────┘
                          │ is_deleted       │
┌──────────────┐          │ created_at       │          ┌──────────────────┐
│    users     │          │ updated_at       │          │  tagging_jobs    │
│──────────────│          └─────────┬────────┘          │──────────────────│
│ id       (PK)│── 1:N ───────────┘│                   │ id           (PK)│
│ tenant_id(FK)│                    └──── 1:N ──────────│ document_id  (FK)│
│ name         │                         │              │ tenant_id       │
│ role         │                         │              │ status          │
│ is_active    │                         │              │ model_version   │
│ first_seen_at│                         │              │ error_message   │
│ last_seen_at │                    ┌────┴─────────┐    │ started_at      │
└──────────────┘                    │  audit_logs  │    │ completed_at    │
                                    │──────────────│    │ created_at      │
                                    │ id       (PK)│    └──────────────────┘
                                    │ tenant_id    │
                                    │ user_id      │
                                    │ action       │
                                    │ resource_type│
                                    │ resource_id  │
                                    │ detail (JSON)│
                                    │ result       │
                                    │ created_at   │
                                    └──────────────┘
```

### 테이블 관계 요약

| 관계 | 설명 |
|------|------|
| tenants 1:N documents | 부서(테넌트)는 여러 문서를 보유한다 |
| users 1:N documents | 사용자는 여러 문서를 업로드한다 |
| documents 1:N tags | 하나의 문서에 여러 태그가 부여된다 |
| documents 1:N tagging_jobs | 하나의 문서에 여러 태깅 작업이 실행될 수 있다 |
| documents 1:N audit_logs | 문서에 대한 감사 로그가 기록된다 |

---

## 3. 테이블 스키마 상세

### 3.1 tenants (테넌트)

테넌트(부서) 정보를 관리하는 테이블이다. 각 테넌트는 독립된 문서 저장 공간과 쿼터를 가진다.

```sql
CREATE TABLE tenants (
    id          VARCHAR(36)     PRIMARY KEY,
    name        VARCHAR(100)    NOT NULL,
    code        VARCHAR(20)     NOT NULL UNIQUE,
    quota_bytes BIGINT          NOT NULL DEFAULT 107374182400,
    used_bytes  BIGINT          NOT NULL DEFAULT 0,
    is_active   BOOLEAN         NOT NULL DEFAULT TRUE,
    created_at  DATETIME(6)     NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
    updated_at  DATETIME(6)     NOT NULL DEFAULT CURRENT_TIMESTAMP(6)
                                ON UPDATE CURRENT_TIMESTAMP(6)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 컬럼 설명

| 컬럼 | 타입 | 제약조건 | 설명 |
|------|------|---------|------|
| id | VARCHAR(36) | PK | UUID v4 형식의 테넌트 식별자 |
| name | VARCHAR(100) | NOT NULL | 테넌트(부서) 이름 |
| code | VARCHAR(20) | NOT NULL, UNIQUE | 테넌트 코드 (예: dept-a) |
| quota_bytes | BIGINT | NOT NULL, DEFAULT 100GB | 스토리지 할당 용량 (바이트) |
| used_bytes | BIGINT | NOT NULL, DEFAULT 0 | 현재 사용 중인 용량 (바이트) |
| is_active | BOOLEAN | NOT NULL, DEFAULT TRUE | 테넌트 활성화 여부 |
| created_at | DATETIME(6) | NOT NULL | 생성 시각 (마이크로초) |
| updated_at | DATETIME(6) | NOT NULL | 수정 시각 (자동 갱신) |

---

### 3.2 users (사용자)

사용자 정보를 관리하는 테이블이다. 인증은 외부 시스템(Keycloak 등)에서 처리하며, 이 테이블은 서비스 내부 사용자 레코드를 관리한다.

```sql
CREATE TABLE users (
    id              VARCHAR(36)     PRIMARY KEY,
    tenant_id       VARCHAR(36)     NOT NULL,
    name            VARCHAR(100)    NOT NULL,
    role            ENUM('platform-admin','dept-admin','dept-user','viewer')
                                    NOT NULL DEFAULT 'dept-user',
    is_active       BOOLEAN         NOT NULL DEFAULT TRUE,
    first_seen_at   DATETIME(6)     NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
    last_seen_at    DATETIME(6)     NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    INDEX idx_users_tenant (tenant_id),
    INDEX idx_users_role (role)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 컬럼 설명

| 컬럼 | 타입 | 제약조건 | 설명 |
|------|------|---------|------|
| id | VARCHAR(36) | PK | UUID v4 형식의 사용자 식별자 |
| tenant_id | VARCHAR(36) | FK, NOT NULL | 소속 테넌트 ID |
| name | VARCHAR(100) | NOT NULL | 사용자 이름 |
| role | ENUM | NOT NULL | 역할 (platform-admin, dept-admin, dept-user, viewer) |
| is_active | BOOLEAN | NOT NULL | 계정 활성화 여부 |
| first_seen_at | DATETIME(6) | NOT NULL | 최초 접속 시각 |
| last_seen_at | DATETIME(6) | NOT NULL | 마지막 접속 시각 |

---

### 3.3 documents (문서)

업로드된 문서의 메타데이터를 관리하는 핵심 테이블이다. 문서 원본 파일은 오브젝트 스토리지(Ceph RGW)에 저장되며, 이 테이블은 메타데이터만 보관한다. 텍스트 직접 입력과 파일 업로드를 모두 지원하며, `document_type`으로 구분한다.

```sql
CREATE TABLE documents (
    id              VARCHAR(36)     PRIMARY KEY,
    tenant_id       VARCHAR(36)     NOT NULL,
    uploaded_by     VARCHAR(36)     NOT NULL,
    title           VARCHAR(500)    NOT NULL,
    document_type   ENUM('text','pdf','txt','docx','hwp')
                                    NOT NULL,
    content_text    TEXT,
    file_name       VARCHAR(500),
    file_size       BIGINT,
    mime_type       VARCHAR(100),
    sha256_hash     CHAR(64),
    storage_key     VARCHAR(1000),
    ocr_text        TEXT,
    tagging_status  ENUM('PENDING','PROCESSING','COMPLETED','FAILED')
                                    NOT NULL DEFAULT 'PENDING',
    is_deleted      BOOLEAN         NOT NULL DEFAULT FALSE,
    created_at      DATETIME(6)     NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
    updated_at      DATETIME(6)     NOT NULL DEFAULT CURRENT_TIMESTAMP(6)
                                    ON UPDATE CURRENT_TIMESTAMP(6),
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    FOREIGN KEY (uploaded_by) REFERENCES users(id),
    INDEX idx_doc_tenant (tenant_id),
    INDEX idx_doc_status (tagging_status),
    INDEX idx_doc_hash (sha256_hash),
    FULLTEXT INDEX ft_doc_title (title),
    FULLTEXT INDEX ft_doc_content (content_text)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

> **document_type별 컬럼 사용:**
> - `text` 타입: content_text 필수, file_name/file_size/mime_type/sha256_hash/storage_key는 NULL
> - 파일 타입(pdf/txt/docx/hwp): file_name/file_size/mime_type/sha256_hash/storage_key 필수, content_text는 NULL (OCR 후 ocr_text에 저장)

#### 컬럼 설명

| 컬럼 | 타입 | 제약조건 | 설명 |
|------|------|---------|------|
| id | VARCHAR(36) | PK | UUID v4 형식의 문서 식별자 |
| tenant_id | VARCHAR(36) | FK, NOT NULL | 소속 부서(테넌트) ID |
| uploaded_by | VARCHAR(36) | FK, NOT NULL | 업로드한 사용자 ID |
| title | VARCHAR(500) | NOT NULL | 문서 제목 |
| document_type | ENUM | NOT NULL | 문서 유형 (text/pdf/txt/docx/hwp) |
| content_text | TEXT | | 텍스트 직접 입력 내용 (text 타입 시 필수) |
| file_name | VARCHAR(500) | | 원본 파일명 (파일 업로드 시 필수) |
| file_size | BIGINT | | 파일 크기 (바이트, 최대 20MB) |
| mime_type | VARCHAR(100) | | MIME 타입 (예: application/pdf) |
| sha256_hash | CHAR(64) | | 파일 해시값 (중복 검출용, 파일 업로드 시) |
| storage_key | VARCHAR(1000) | | 오브젝트 스토리지 경로 (파일 업로드 시) |
| ocr_text | TEXT | | OCR 추출 텍스트 (파일 타입 문서의 OCR 결과) |
| tagging_status | ENUM | NOT NULL | AI 태깅 처리 상태 |
| is_deleted | BOOLEAN | NOT NULL, DEFAULT FALSE | 소프트 삭제 여부 |
| created_at | DATETIME(6) | NOT NULL | 생성 시각 |
| updated_at | DATETIME(6) | NOT NULL | 수정 시각 (자동 갱신) |

---

### 3.4 tags (태그)

문서에 부여된 태그 정보를 관리하는 테이블이다. AI 자동 태깅 결과, 사전 태깅 데이터(IMPORT), 또는 사용자 수동 태깅 결과를 저장한다.

```sql
CREATE TABLE tags (
    id              BIGINT          AUTO_INCREMENT PRIMARY KEY,
    document_id     VARCHAR(36)     NOT NULL,
    tenant_id       VARCHAR(36)     NOT NULL,
    name            VARCHAR(100)    NOT NULL,
    confidence      DECIMAL(5,4),
    source          ENUM('AI','IMPORT','MANUAL') NOT NULL DEFAULT 'AI',
    model_version   VARCHAR(50),
    created_by      VARCHAR(36),
    created_at      DATETIME(6)     NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
    FOREIGN KEY (document_id) REFERENCES documents(id),
    INDEX idx_tags_doc (document_id),
    INDEX idx_tags_tenant (tenant_id),
    INDEX idx_tags_name (name),
    FULLTEXT INDEX ft_tags_name (name)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 컬럼 설명

| 컬럼 | 타입 | 제약조건 | 설명 |
|------|------|---------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 태그 레코드 식별자 |
| document_id | VARCHAR(36) | FK, NOT NULL | 대상 문서 ID |
| tenant_id | VARCHAR(36) | NOT NULL | 소속 테넌트 ID (비정규화) |
| name | VARCHAR(100) | NOT NULL | 태그 이름 |
| confidence | DECIMAL(5,4) | | AI 태깅 신뢰도 (0.0000 ~ 1.0000) |
| source | ENUM | NOT NULL | 태그 생성 출처 (AI / IMPORT / MANUAL) |
| model_version | VARCHAR(50) | | AI 모델 버전 (AI 태깅 시) |
| created_by | VARCHAR(36) | | 수동 태깅 시 생성 사용자 ID |
| created_at | DATETIME(6) | NOT NULL | 생성 시각 |

#### source 값 정의

| source | 설명 | confidence | model_version |
|--------|------|-----------|--------------|
| `AI` | AI 자동 태깅 (KoBERT 모델 추론 결과) | 모델 예측 신뢰도 (0.0~1.0) | 모델 버전 (예: kobert-v1.0) |
| `IMPORT` | 사전 태깅 데이터 일괄 업로드 (학습 데이터 등) | `1.0` (확정) | `NULL` |
| `MANUAL` | 사용자 수동 태깅 (MVP 제외) | `NULL` | `NULL` |

---

### 3.5 tagging_jobs (태깅 작업)

AI 태깅 작업의 실행 이력을 관리하는 테이블이다. 문서 업로드 시 비동기로 생성되는 태깅 작업의 상태를 추적한다.

```sql
CREATE TABLE tagging_jobs (
    id              VARCHAR(36)     PRIMARY KEY,
    document_id     VARCHAR(36)     NOT NULL,
    tenant_id       VARCHAR(36)     NOT NULL,
    status          ENUM('PENDING','PROCESSING','COMPLETED','FAILED')
                                    NOT NULL DEFAULT 'PENDING',
    model_version   VARCHAR(50),
    error_message   TEXT,
    started_at      DATETIME(6),
    completed_at    DATETIME(6),
    created_at      DATETIME(6)     NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
    FOREIGN KEY (document_id) REFERENCES documents(id),
    INDEX idx_jobs_status (status),
    INDEX idx_jobs_doc (document_id),
    INDEX idx_jobs_tenant (tenant_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 컬럼 설명

| 컬럼 | 타입 | 제약조건 | 설명 |
|------|------|---------|------|
| id | VARCHAR(36) | PK | UUID v4 형식의 작업 식별자 |
| document_id | VARCHAR(36) | FK, NOT NULL | 대상 문서 ID |
| tenant_id | VARCHAR(36) | NOT NULL | 소속 테넌트 ID (비정규화) |
| status | ENUM | NOT NULL | 작업 상태 (PENDING/PROCESSING/COMPLETED/FAILED) |
| model_version | VARCHAR(50) | | 사용된 AI 모델 버전 |
| error_message | TEXT | | 실패 시 오류 메시지 |
| started_at | DATETIME(6) | | 작업 시작 시각 |
| completed_at | DATETIME(6) | | 작업 완료 시각 |
| created_at | DATETIME(6) | NOT NULL | 레코드 생성 시각 |

---

### 3.6 audit_logs (감사 로그)

시스템 내 주요 활동에 대한 감사 로그를 기록하는 테이블이다. 문서 업로드, 삭제, 태그 수정 등 모든 변경 이력을 추적한다.

```sql
CREATE TABLE audit_logs (
    id              BIGINT          AUTO_INCREMENT PRIMARY KEY,
    tenant_id       VARCHAR(36),
    user_id         VARCHAR(36)     NOT NULL,
    action          VARCHAR(50)     NOT NULL,
    resource_type   VARCHAR(50)     NOT NULL,
    resource_id     VARCHAR(36),
    detail          JSON,
    source_ip       VARCHAR(45),
    request_id      VARCHAR(36)     NOT NULL,
    result          ENUM('SUCCESS','FAILURE') NOT NULL,
    created_at      DATETIME(6)     NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
    INDEX idx_audit_tenant (tenant_id),
    INDEX idx_audit_user (user_id),
    INDEX idx_audit_action (action),
    INDEX idx_audit_created (created_at),
    INDEX idx_audit_resource (resource_type, resource_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 컬럼 설명

| 컬럼 | 타입 | 제약조건 | 설명 |
|------|------|---------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 로그 레코드 식별자 |
| tenant_id | VARCHAR(36) | | 대상 테넌트 ID (시스템 작업 시 NULL) |
| user_id | VARCHAR(36) | NOT NULL | 행위 주체 사용자 ID |
| action | VARCHAR(50) | NOT NULL | 수행된 동작 (UPLOAD, DELETE, TAG_ADD 등) |
| resource_type | VARCHAR(50) | NOT NULL | 대상 리소스 유형 (DOCUMENT, TAG 등) |
| resource_id | VARCHAR(36) | | 대상 리소스 ID |
| detail | JSON | | 변경 상세 내용 (이전값/이후값 등) |
| source_ip | VARCHAR(45) | | 요청 출발 IP (IPv6 대응) |
| request_id | VARCHAR(36) | NOT NULL | 요청 추적 ID (분산 트레이싱용) |
| result | ENUM | NOT NULL | 수행 결과 (SUCCESS / FAILURE) |
| created_at | DATETIME(6) | NOT NULL | 기록 시각 |

#### action 코드 정의

| action | 설명 |
|--------|------|
| DOCUMENT_UPLOAD | 문서 업로드 |
| DOCUMENT_DELETE | 문서 삭제 |
| DOCUMENT_DOWNLOAD | 문서 다운로드 |
| TAG_ADD | 태그 추가 (수동) |
| TAG_REMOVE | 태그 삭제 |
| TAG_AUTO | AI 자동 태깅 완료 |
| USER_LOGIN | 사용자 로그인 |
| USER_LOGOUT | 사용자 로그아웃 |
| TENANT_UPDATE | 테넌트 정보 변경 |

---

## 4. 인덱스 전략

### 4.1 인덱스 설계 원칙

| 원칙 | 설명 |
|------|------|
| **테넌트 격리** | 모든 데이터 테이블에 tenant_id 인덱스를 적용하여 테넌트별 조회 성능을 보장한다 |
| **전문 검색** | 문서 제목/설명과 태그 이름에 FULLTEXT 인덱스를 적용한다 |
| **복합 인덱스** | 자주 함께 조회되는 컬럼에 복합 인덱스를 적용한다 |
| **최소 원칙** | 불필요한 인덱스를 생성하지 않아 쓰기 성능을 유지한다 |

### 4.2 인덱스 전체 목록

| 테이블 | 인덱스 이름 | 대상 컬럼 | 유형 | 용도 |
|--------|------------|----------|------|------|
| tenants | PRIMARY | id | PK | 기본 키 조회 |
| tenants | code | code | UNIQUE | 테넌트 코드 조회 |
| users | PRIMARY | id | PK | 기본 키 조회 |
| users | idx_users_tenant | tenant_id | B-Tree | 테넌트별 사용자 목록 |
| users | idx_users_role | role | B-Tree | 역할별 사용자 필터링 |
| documents | PRIMARY | id | PK | 기본 키 조회 |
| documents | idx_doc_tenant | tenant_id | B-Tree | 부서별 문서 목록 |
| documents | idx_doc_status | tagging_status | B-Tree | 태깅 상태별 필터링 |
| documents | idx_doc_hash | sha256_hash | B-Tree | 중복 파일 검출 |
| documents | ft_doc_title | title | FULLTEXT | 문서 제목 전문 검색 |
| documents | ft_doc_content | content_text | FULLTEXT | 문서 내용 전문 검색 |
| tags | PRIMARY | id | PK | 기본 키 조회 |
| tags | idx_tags_doc | document_id | B-Tree | 문서별 태그 목록 |
| tags | idx_tags_tenant | tenant_id | B-Tree | 부서별 태그 조회 |
| tags | idx_tags_name | name | B-Tree | 태그 이름 검색 |
| tags | ft_tags_name | name | FULLTEXT | 태그 전문 검색 |
| tagging_jobs | PRIMARY | id | PK | 기본 키 조회 |
| tagging_jobs | idx_jobs_status | status | B-Tree | 상태별 작업 조회 |
| tagging_jobs | idx_jobs_doc | document_id | B-Tree | 문서별 작업 이력 |
| tagging_jobs | idx_jobs_tenant | tenant_id | B-Tree | 부서별 작업 목록 |
| audit_logs | PRIMARY | id | PK | 기본 키 조회 |
| audit_logs | idx_audit_tenant | tenant_id | B-Tree | 부서별 감사 로그 |
| audit_logs | idx_audit_user | user_id | B-Tree | 사용자별 활동 이력 |
| audit_logs | idx_audit_action | action | B-Tree | 동작 유형별 필터링 |
| audit_logs | idx_audit_created | created_at | B-Tree | 시간 범위 조회 |
| audit_logs | idx_audit_resource | resource_type, resource_id | Composite | 특정 리소스 감사 이력 |

### 4.3 주요 쿼리 패턴과 인덱스 활용

| 쿼리 패턴 | 사용 인덱스 | 설명 |
|-----------|------------|------|
| 부서별 문서 목록 조회 | idx_doc_tenant | WHERE tenant_id = ? AND is_deleted = FALSE |
| 태깅 대기 문서 조회 | idx_doc_status | WHERE tagging_status = 'PENDING' |
| 문서 제목 검색 | ft_doc_title | MATCH(title) AGAINST(? IN BOOLEAN MODE) |
| 문서 내용 검색 | ft_doc_content | MATCH(content_text) AGAINST(? IN BOOLEAN MODE) |
| 태그 이름 검색 | ft_tags_name | MATCH(name) AGAINST(? IN BOOLEAN MODE) |
| 중복 파일 검출 | idx_doc_hash | WHERE sha256_hash = ? AND tenant_id = ? |
| 감사 로그 기간 조회 | idx_audit_created | WHERE created_at BETWEEN ? AND ? |
| 리소스별 감사 이력 | idx_audit_resource | WHERE resource_type = ? AND resource_id = ? |

---

## 5. 읽기/쓰기 분리

### 5.1 아키텍처 개요

MariaDB Primary-Replica 구성에서 읽기 트래픽을 Replica로 분산하여 Primary의 쓰기 부하를 줄인다.

```
┌─────────────────┐
│   App 서버      │
│   (Spring Boot) │
│                 │
│ ┌─────────────┐ │
│ │ HikariCP    │ │
│ │ ┌─────────┐ │ │
│ │ │ Primary │ │─│───── Write ─────► dev-data-db-pri (Primary)
│ │ │  Pool   │ │ │
│ │ └─────────┘ │ │
│ │ ┌─────────┐ │ │
│ │ │ Replica │ │─│───── Read  ─────► dev-data-db-rep (Replica)
│ │ │  Pool   │ │ │
│ │ └─────────┘ │ │
│ └─────────────┘ │
└─────────────────┘
```

### 5.2 HikariCP 이중 풀 설정

```yaml
# application.yml
spring:
  datasource:
    primary:
      driver-class-name: org.mariadb.jdbc.Driver
      jdbc-url: jdbc:mariadb://dev-data-db-pri:3306/sesac_smartdocs
      username: ${DB_PRIMARY_USER}
      password: ${DB_PRIMARY_PASS}
      hikari:
        pool-name: primary-pool
        maximum-pool-size: 20
        minimum-idle: 5
        connection-timeout: 3000
        idle-timeout: 600000

    replica:
      driver-class-name: org.mariadb.jdbc.Driver
      jdbc-url: jdbc:mariadb://dev-data-db-rep:3306/sesac_smartdocs
      username: ${DB_REPLICA_USER}
      password: ${DB_REPLICA_PASS}
      hikari:
        pool-name: replica-pool
        maximum-pool-size: 30
        minimum-idle: 10
        connection-timeout: 3000
        idle-timeout: 600000
```

### 5.3 라우팅 구현

Spring의 `AbstractRoutingDataSource`를 활용하여 `@Transactional(readOnly = true)` 어노테이션 기반으로 데이터소스를 자동 라우팅한다.

```java
public class RoutingDataSource extends AbstractRoutingDataSource {

    @Override
    protected Object determineCurrentLookupKey() {
        boolean isReadOnly = TransactionSynchronizationManager
                .isCurrentTransactionReadOnly();
        return isReadOnly ? "replica" : "primary";
    }
}
```

```java
// 읽기 전용 쿼리 - Replica로 라우팅
@Transactional(readOnly = true)
public List<DocumentDto> findByDepartmentId(String departmentId) {
    return documentRepository.findByTenantIdAndIsDeletedFalse(departmentId);
}

// 쓰기 쿼리 - Primary로 라우팅
@Transactional
public DocumentDto upload(DocumentUploadRequest request) {
    Document doc = documentRepository.save(toEntity(request));
    return toDto(doc);
}
```

---

## 6. 검색 설계

### 6.1 검색 방식

MariaDB InnoDB 엔진의 Full-Text Search 기능을 활용하여 문서 검색을 구현한다. 별도의 검색 엔진(Elasticsearch 등) 없이 RDBMS 내에서 전문 검색을 처리한다.

> 향후 검색 요구사항이 고도화될 경우, `SearchService` 인터페이스를 통해 Elasticsearch 등 외부 검색 엔진으로 교체할 수 있도록 설계한다.

### 6.2 검색 대상 필드

| 대상 테이블 | 검색 필드 | FULLTEXT 인덱스 | 설명 |
|------------|----------|----------------|------|
| documents | title | ft_doc_title | 문서 제목 검색 |
| documents | content_text | ft_doc_content | 문서 내용 검색 (텍스트 타입) |
| tags | name | ft_tags_name | 태그 이름 검색 |

### 6.3 검색 SQL 예시

#### 문서 제목/내용 검색

```sql
-- 문서 제목 및 내용에서 키워드 검색
SELECT d.id, d.title, d.document_type, d.file_name,
       d.created_at, d.tagging_status,
       MATCH(d.title) AGAINST(:keyword IN BOOLEAN MODE) AS title_score,
       MATCH(d.content_text) AGAINST(:keyword IN BOOLEAN MODE) AS content_score
  FROM documents d
 WHERE d.tenant_id = :tenantId
   AND d.is_deleted = FALSE
   AND (
       MATCH(d.title) AGAINST(:keyword IN BOOLEAN MODE)
       OR MATCH(d.content_text) AGAINST(:keyword IN BOOLEAN MODE)
   )
 ORDER BY (title_score + content_score) DESC
 LIMIT :size OFFSET :offset;
```

#### 태그 기반 문서 검색

```sql
-- 태그 이름으로 문서 검색
SELECT DISTINCT d.id, d.title, d.file_name,
       d.created_at, d.tagging_status
  FROM documents d
 INNER JOIN tags t ON t.document_id = d.id
 WHERE d.tenant_id = :tenantId
   AND d.is_deleted = FALSE
   AND MATCH(t.name) AGAINST(:tagKeyword IN BOOLEAN MODE)
 ORDER BY d.created_at DESC
 LIMIT :size OFFSET :offset;
```

#### 통합 검색 (문서 + 태그)

```sql
-- 문서 제목/내용 + 태그 이름 통합 검색
SELECT d.id, d.title, d.document_type, d.file_name, d.created_at,
       MATCH(d.title) AGAINST(:keyword IN BOOLEAN MODE) AS title_score,
       MAX(MATCH(t.name) AGAINST(:keyword IN BOOLEAN MODE)) AS tag_score
  FROM documents d
  LEFT JOIN tags t ON t.document_id = d.id
 WHERE d.tenant_id = :tenantId
   AND d.is_deleted = FALSE
   AND (
       MATCH(d.title) AGAINST(:keyword IN BOOLEAN MODE)
       OR MATCH(t.name) AGAINST(:keyword IN BOOLEAN MODE)
   )
 GROUP BY d.id
 ORDER BY (title_score + COALESCE(tag_score, 0)) DESC
 LIMIT :size OFFSET :offset;
```

### 6.4 검색 API 파라미터 매핑

| API 파라미터 | SQL 매핑 | 설명 |
|-------------|---------|------|
| q | AGAINST(:keyword IN BOOLEAN MODE) | 검색 키워드 |
| tenantId | WHERE tenant_id = :tenantId | 부서 필터 (필수, 헤더 기반 자동 적용) |
| status | WHERE tagging_status = :status | 태깅 상태 필터 |
| page | OFFSET (page * size) | 페이지 번호 (0-based) |
| size | LIMIT :size | 페이지 크기 (기본값 20) |
| sort | ORDER BY :sort | 정렬 기준 (relevance, created_at) |

### 6.5 SearchService 인터페이스 (확장 대비)

```java
public interface SearchService {

    /**
     * 문서 통합 검색
     * 현재: MariaDB Full-Text Search
     * 향후: Elasticsearch 등으로 교체 가능
     */
    Page<DocumentSearchResult> search(
        String tenantId,
        String keyword,
        SearchFilter filter,
        Pageable pageable
    );
}
```

---

## 7. 초기 스키마 스크립트

### 7.1 SQL 스크립트 구조

```
sql/
├── 01_init_schema.sql          # 데이터베이스 생성 및 테이블 DDL
├── 02_insert_initial_data.sql  # 초기 테넌트/관리자 데이터
└── ...                         # 이후 변경사항
```

별도의 마이그레이션 도구(Flyway 등) 없이 SQL 스크립트를 직접 실행하여 스키마를 초기화한다.

### 7.2 01_init_schema.sql

초기 스키마 스크립트는 위 [3. 테이블 스키마 상세](#3-테이블-스키마-상세)에 정의된 6개 테이블의 CREATE TABLE DDL을 순서대로 포함한다.

```sql
-- ============================================================
-- SmartDocs 초기 스키마
-- Database: sesac_smartdocs / MariaDB 11.4 LTS
-- 테이블 생성 순서: tenants → users → documents → tags → tagging_jobs → audit_logs
-- 전체 DDL은 본 문서 3장 참조
-- ============================================================

CREATE DATABASE IF NOT EXISTS sesac_smartdocs
    CHARACTER SET utf8mb4
    COLLATE utf8mb4_unicode_ci;

USE sesac_smartdocs;

-- 1. tenants       (3.1절 DDL)
-- 2. users         (3.2절 DDL)
-- 3. documents     (3.3절 DDL)
-- 4. tags          (3.4절 DDL)
-- 5. tagging_jobs  (3.5절 DDL)
-- 6. audit_logs    (3.6절 DDL)
```

### 7.3 02_insert_initial_data.sql

초기 테넌트(부서) 3개와 플랫폼 관리자 계정을 삽입한다.

```sql
-- ============================================================
-- 초기 테넌트 및 관리자 데이터
-- ============================================================

-- 테넌트 (부서 A, B, C)
INSERT INTO tenants (id, name, code, quota_bytes) VALUES
    (UUID(), '부서 A', 'dept-a', 107374182400),
    (UUID(), '부서 B', 'dept-b', 107374182400),
    (UUID(), '부서 C', 'dept-c', 107374182400);
```

---

## 변경 이력

| 버전 | 날짜 | 변경 내용 | 작성자 |
|------|------|----------|--------|
| 1.0 | 2026-02-09 | 초안 작성 | - |
| 2.0 | 2026-02-10 | documents 테이블에 document_type/content_text/ocr_text 추가, VLAN 50→40, 검색 쿼리 업데이트 | - |

---

## 관련 문서

- [07_백엔드_설계서.md](07_백엔드_설계서.md) - 백엔드 설계서 (상위 문서)
- [04_컴퓨트_설계서.md](04_컴퓨트_설계서.md) - 컴퓨트 설계서 (DB 서버 사양)
- [05_네트워크_보안_설계서.md](05_네트워크_보안_설계서.md) - 네트워크/보안 설계서 (VLAN 40 - DB망)
- [06_스토리지_설계서.md](06_스토리지_설계서.md) - 스토리지 설계서 (DB 볼륨)
